# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VS1C_Xv-l514g69YHfODFcJNOnoxxikx
"""

""" importanción de librerias """
import pandas as pd
import seaborn as sb
import matplotlib as plt

""" conexión con la nube """
from google.colab import drive # type: ignore


drive.mount('/gdrive')

""" referencia de ruta """
path_ = "/gdrive/MyDrive/data_Cust_Mkt/dataset_banco.csv"

""" seteo del dataset en una variable """
dataf = pd.read_csv(path_)




""" INFO GENERAL DEL DATASET """
pd.read_csv(path_).info()

pd.read_csv(path_).head()

pd.read_csv(path_).shape

""" OTRA FORMA... """

dataf.info()

dataf.shape

""" Datos faltantes -> Se procede a eliminar las filas cuyos campos presenten un valor no especificado o vacio"""
"""  Recordermos:   CASO DE MISSING VALUES
        * Nat -> caso columna tipo de dato: datetime
        * NaN -> caso columna tipo de dato: Numérico
        * <Na> -> caso columna tipo de datos: Nullable
 """
""" Eliminamos dichos registros y actualizamos la tabla o BD original """
dataf.dropna(inplace=True)


''' Columna irrelevante:
Puede ser debido a ..
* No aporta información o no guarda relación con lo que se está buscando
* Tiene valores repetidos o redundante
* Columna de variable categórica de un solo nivel
* Columna de variable numérica de un solo valor
'''

""" 1RA FORMA DE SOLUCIÓN: """
unicos = dataf['y'].nunique()
if unicos == 1:
  print("La columna de var. categórica tiene ",{unicos}," subnivel")
else:
  print("La columna de var. categórica tiene ",{unicos}," subniveles")


  """ 2DA FORMA """
cols_categ = ['job','marital','education','default','housing','loan','contact','month','poutcome','y']

for columnita in cols_categ:
  print(f"columna:{columnita} 'presenta' {dataf[columnita].nunique()} subniveles")


""" Elimianción de duplicados """

dataf.drop_duplicates(inplace=True)
dataf.shape


''' Otliers -> valores atipicos encontrados en los dataset,
    * Se puede manejar, con una eliminación, una transofrmación, un tratamiento estadístico
    * Es importante, hacer una evaluación previa y determinar como manejar estos datos,
      ya que pueden aportar alto valor en la información.

 Para esta evaluación, se necesita:
 Generar gráficas individuales  para columnas con tipo de dato numérico'''

cols_num = ['age','balance','day','duration','campaign','pdays','previous']

fig, ax = plt.subplots(nrows=7, ncols=1, figsize=(8,30))
fig.subplots_adjust(hspace=0.5)

for i, col in enumerate(cols_num):
  sb.boxplot(x=col, data=dataf, ax=ax[i])
  ax[i].set_title(col)


#1ro consideremos solamente edades menores iguales que 100 
dataf = dataf[dataf['age'] <= 100]

# 2do, eliminación de valores negativos de la columna: duración
dataf = dataf[dataf['duration'] > 0]

# Previous call , vamos a cosndierar solo menores o iguales que 100
dataf = dataf[dataf['previous'] <= 100] 


''' Limpieza: errores ortográficos,

 Gráficar con countplot(), los subniveles de las variables categóricas '''

cols_cat = ['job', 'marital', 'education', 'default', 'housing', 'loan','contact', 'month', 'poutcome','y']

fig, ax = plt.subplots(nrows=10, ncols=1, figsize=(10,30))
fig.subplots_adjust(hspace=1)

  #Enumerate() ha llamado a cols_cat como un objeto iterable, '''
for i, col in enumerate(cols_cat):
  #uso de gráfico de conteo
  sb.countplot(x=col, data=dataf, ax=ax[i])
  ax[i].set_title(col)
  ax[i].set_xticklabels(ax[i].get_xticklabels(),rotation=30)


# para la limpieza: vamos a pasar los subniveles que comienzan con MAYUSC o son todos MAYUSC a minuscula

for i,columns in enumerate(dataf.columns,1):
  if columns in cols_cat :
    dataf[columns] = dataf[columns].str.lower()
    print(f"columna {i} : {columns}")

#Respecto a columna Job, vamos a unir 'admin.' con 'administrative'

print(dataf['job'].unique())
dataf['job'] = dataf['job'].str.replace('admin.','administrative')
print(dataf['job'].unique())

#Respecto a columna marital, vamos a unir 'div.' con 'divorced'

print(dataf['marital'].unique())
dataf['marital'] = dataf['marital'].str.replace('div.','divorced')
print(dataf['marital'].unique())

#Respecto a columna marital, vamos a unir 'sec.' con 'secondary'

print(dataf['education'].unique())
dataf['education'] = dataf['education'].str.replace('sec.','secondary')
print(dataf['education'].unique())

#Respecto a columna contact, vamos a unir 'phone' con 'telephone'

print(dataf['contact'].unique())
dataf[dataf['contact']=='phone'] = 'telephone'
print(dataf['contact'].unique())

#Respecto a columna contact, vamos a unir 'unk' con 'unknown'

print(dataf['poutcome'].unique())
dataf[dataf['poutcome']=='unk'] = 'unknown'
print(dataf['poutcome'].unique())